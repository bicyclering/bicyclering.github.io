---
title: 技巧
tags: IOS
abbrlink: 42113
date: 2018-01-18 21:17:19
---


# 最简单的方法来改变字母大小写的情况


	在这里，我们将讨论改变字母大小写的最简单和最简单的方法。提示：我们将使用点位操作技巧。


通常在编程需要的时候，我们需要改变字母的大小写。这可能是一个问题的要求，或者只是我们需要解决的问题。有几种方法可以做到这一点，但是比起使用相同的方法，有什么更优美的方法,也就是用比特技巧解决问题。


我们在这些帖子中讨论一些比特操作技巧：

* [低级别的位操作技巧](/2018/01/19/IOS-Skill-技巧-SomeAdvancedBitHacks/#more)
* [一些先进的位操作技巧](/2018/01/19/IOS-Skill-技巧-LowLevelBitHacks/#more)

在这里我想讨论一下ASCII技巧，将小写字母转换为大写字母和后面的。诀窍是非常简单，你是第六位（或第五位取决于你如何计数位），并改变了情况！
看一下这个：

	 a = 01100001
	 A = 01000001

看，只是第六位变了。

这是为什么？只是因为发明ASCII的人认为这是一个好主意。如果你看字符a..z，你会发现它们都是第六位设为1.但是，ASCII发明者，嘿，我们将第六位设置为0来表示大写字母A..Z，然后它将是超级容易改变的情况。所以他们做到了。

	a = 01100001    A = 01000001 
	b = 01100010    B = 01000010 
	c = 01100011    C = 01000011 
	d = 01100100    D = 01000100 
	e = 01100101    E = 01000101 
	f = 01100110    F = 01000110 
	g = 01100111    G = 01000111 
	h = 01101000    H = 01001000 
	i = 01101001    I = 01001001 
	j = 01101010    J = 01001010 
	k = 01101011    K = 01001011 
	l = 01101100    L = 01001100 
	m = 01101101    M = 01001101 
	n = 01101110    N = 01001110 
	o = 01101111    O = 01001111 
	p = 01110000    P = 01010000 
	q = 01110001    Q = 01010001 
	r = 01110010    R = 01010010 
	s = 01110011    S = 01010011 
	t = 01110100    T = 01010100 
	u = 01110101    U = 01010101 
	v = 01110110    V = 01010110 
	w = 01110111    W = 01010111 
	x = 01111000    X = 01011000 
	y = 01111001    Y = 01011001 
	z = 01111010    Z = 01011010

也检查了这一点，如果你与一个空间异或字符，你反转的情况下：


	#include<stdio.h>
	int main(void)
	{
	    char x = 'A';
	    char y = 'b';
	 
	    printf("Original case:- %c %c",x,y);
	 
	    x = x ^ ' ';
	    y = y ^ ' ';
	 
	    printf("\n\nChanged case:- %c %c",x,y);
	 
	    return 0;
	}
	
	
这是为什么？因为一个空格的ASCII值是32，这个是1 << 5(1左移5位)，这是第6位，交换的情况！

原文来自[http://www.studyalgorithms.com/string/easiest-way-to-change-case-of-alphabets/](http://www.studyalgorithms.com/string/easiest-way-to-change-case-of-alphabets/)